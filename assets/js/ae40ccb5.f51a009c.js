"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2632],{1278:n=>{n.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"building-custom-tool","metadata":{"permalink":"/hexagon/blog/building-custom-tool","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2026-01-06-building-custom-tool.md","source":"@site/blog/2026-01-06-building-custom-tool.md","title":"Tutorial: Building a Custom Tool","description":"This tutorial walks you through building a real custom tool for Hexagon. You\'ll learn how to create a tool that makes API requests, handles user input, and provides rich output.","date":"2026-01-06T00:00:00.000Z","tags":[{"inline":false,"label":"Tutorial","permalink":"/hexagon/blog/tags/tutorial","description":"Step-by-step guides for using Hexagon"},{"inline":false,"label":"Custom Tools","permalink":"/hexagon/blog/tags/custom-tools","description":"Building custom Python tools for Hexagon"},{"inline":false,"label":"Python","permalink":"/hexagon/blog/tags/python","description":"Python-related content and development"}],"readingTime":6.935,"hasTruncateMarker":true,"authors":[{"name":"Joaco Campero","title":"Creator of Hexagon","url":"https://github.com/lt-mayonesa","page":{"permalink":"/hexagon/blog/authors/joaco"},"socials":{"github":"https://github.com/lt-mayonesa"},"imageURL":"https://github.com/lt-mayonesa.png","key":"joaco"}],"frontMatter":{"slug":"building-custom-tool","title":"Tutorial: Building a Custom Tool","authors":["joaco"],"tags":["tutorial","custom-tools","python"]},"unlisted":false,"nextItem":{"title":"Tutorial: Multi-Environment Workflow","permalink":"/hexagon/blog/multi-environment-workflow"}},"content":"This tutorial walks you through building a real custom tool for Hexagon. You\'ll learn how to create a tool that makes API requests, handles user input, and provides rich output.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What We\'ll Build\\n\\nWe\'ll create a **GitHub Repository Info** tool that:\\n- Fetches information about a GitHub repository\\n- Accepts repository name as an argument\\n- Shows stars, forks, and description\\n- Handles errors gracefully\\n- Works with different GitHub API tokens per environment\\n\\n## Prerequisites\\n\\n- Hexagon installed\\n- A CLI project with `app.yaml` configuration\\n- Basic Python knowledge\\n\\n## Step 1: Set Up Custom Tools Directory\\n\\nFirst, configure your CLI to use a custom tools directory:\\n\\n```yaml\\n# app.yaml\\ncli:\\n  name: My CLI\\n  command: mycli\\n  custom_tools_dir: ./custom_tools  # Add this line\\n```\\n\\nCreate the directory:\\n\\n```bash\\nmkdir -p custom_tools\\n```\\n\\n## Step 2: Create the Tool File\\n\\nCreate a new Python file for your tool:\\n\\n```bash\\ntouch custom_tools/github_info.py\\n```\\n\\n## Step 3: Define Arguments\\n\\nStart by defining the arguments your tool will accept:\\n\\n```python\\n# custom_tools/github_info.py\\nfrom hexagon.support.input.args import ToolArgs, PositionalArg, OptionalArg, Arg\\n\\nclass Args(ToolArgs):\\n    \\"\\"\\"Arguments for the GitHub info tool.\\"\\"\\"\\n\\n    repo: PositionalArg[str] = Arg(\\n        None,\\n        prompt_message=\\"Enter repository (format: owner/repo)\\",\\n        description=\\"GitHub repository in owner/repo format\\"\\n    )\\n\\n    show_details: OptionalArg[bool] = Arg(\\n        False,\\n        alias=\\"d\\",\\n        description=\\"Show detailed information\\"\\n    )\\n```\\n\\n**What\'s happening here:**\\n- `PositionalArg[str]`: Required argument that must be provided\\n- `OptionalArg[bool]`: Optional flag with default value\\n- `prompt_message`: Message shown if argument not provided\\n- `alias`: Short form for the argument (`--show-details` or `-d`)\\n\\n## Step 4: Implement the Main Function\\n\\nAdd the main function that will execute when the tool runs:\\n\\n```python\\nfrom hexagon.support.output.printer import log\\nimport urllib.request\\nimport json\\n\\ndef main(tool, env, env_args, cli_args: Args):\\n    \\"\\"\\"Fetch and display GitHub repository information.\\n\\n    Args:\\n        tool: Tool configuration object\\n        env: Selected environment (or None)\\n        env_args: Environment-specific configuration\\n        cli_args: Parsed command-line arguments\\n    \\"\\"\\"\\n    # Prompt for repo if not provided\\n    if not cli_args.repo.value:\\n        cli_args.repo.prompt()\\n\\n    # Validate repo format\\n    repo = cli_args.repo.value\\n    if \\"/\\" not in repo:\\n        log.error(\\"Invalid repository format. Use: owner/repo\\")\\n        return [\\"Error: Invalid repository format\\"]\\n\\n    # Show what we\'re doing\\n    log.info(f\\"Fetching information for: {repo}\\")\\n\\n    # Make the API request\\n    try:\\n        url = f\\"https://api.github.com/repos/{repo}\\"\\n\\n        # Add authentication token if provided via environment\\n        headers = {}\\n        if env_args and isinstance(env_args, dict) and \\"token\\" in env_args:\\n            headers[\\"Authorization\\"] = f\\"token {env_args[\'token\']}\\"\\n\\n        request = urllib.request.Request(url, headers=headers)\\n        with urllib.request.urlopen(request) as response:\\n            data = json.loads(response.read().decode())\\n\\n        # Extract key information\\n        name = data[\\"full_name\\"]\\n        description = data[\\"description\\"] or \\"No description\\"\\n        stars = data[\\"stargazers_count\\"]\\n        forks = data[\\"forks_count\\"]\\n        language = data[\\"language\\"] or \\"Not specified\\"\\n\\n        # Display results\\n        log.panel(\\n            f\\"**{name}**\\\\n\\\\n{description}\\",\\n            title=\\"Repository Info\\"\\n        )\\n\\n        results = [\\n            f\\"\u2b50 Stars: {stars:,}\\",\\n            f\\"\ud83c\udf74 Forks: {forks:,}\\",\\n            f\\"\ud83d\udcbb Language: {language}\\"\\n        ]\\n\\n        # Show additional details if requested\\n        if cli_args.show_details.value:\\n            results.extend([\\n                f\\"\ud83d\udcc5 Created: {data[\'created_at\'][:10]}\\",\\n                f\\"\ud83d\udcdd Updated: {data[\'updated_at\'][:10]}\\",\\n                f\\"\ud83d\udc1b Open Issues: {data[\'open_issues_count\']}\\"\\n            ])\\n\\n        return results\\n\\n    except urllib.error.HTTPError as e:\\n        if e.code == 404:\\n            log.error(f\\"Repository not found: {repo}\\")\\n            return [f\\"Error: Repository \'{repo}\' not found\\"]\\n        elif e.code == 403:\\n            log.error(\\"API rate limit exceeded. Use a GitHub token.\\")\\n            return [\\"Error: API rate limit exceeded\\"]\\n        else:\\n            log.error(f\\"GitHub API error: {e.code}\\")\\n            return [f\\"Error: GitHub API returned {e.code}\\"]\\n\\n    except Exception as e:\\n        log.error(f\\"Unexpected error: {str(e)}\\")\\n        return [f\\"Error: {str(e)}\\"]\\n```\\n\\n## Step 5: Add Tool to Configuration\\n\\nNow add your tool to `app.yaml`:\\n\\n```yaml\\ntools:\\n  - name: github-info\\n    alias: gh\\n    long_name: GitHub Repository Info\\n    description: Get information about a GitHub repository\\n    type: shell\\n    action: github_info\\n```\\n\\n## Step 6: Test Your Tool\\n\\nTest the basic functionality:\\n\\n```bash\\n# With repo as argument\\nmycli github-info facebook/react\\n\\n# Without argument (will prompt)\\nmycli github-info\\n\\n# With details flag\\nmycli github-info facebook/react --show-details\\n```\\n\\nYou should see output like:\\n\\n```\\nFetching information for: facebook/react\\n\\n\u250c\u2500 Repository Info \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502 **facebook/react**                           \u2502\\n\u2502                                              \u2502\\n\u2502 The library for web and native interfaces   \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n\u2b50 Stars: 230,000\\n\ud83c\udf74 Forks: 47,000\\n\ud83d\udcbb Language: JavaScript\\n```\\n\\n## Step 7: Add Environment Support\\n\\nLet\'s add support for different GitHub tokens per environment:\\n\\n```yaml\\nenvs:\\n  - name: personal\\n    alias: p\\n  - name: work\\n    alias: w\\n\\ntools:\\n  - name: github-info\\n    alias: gh\\n    long_name: GitHub Repository Info\\n    description: Get information about a GitHub repository\\n    type: shell\\n    action: github_info\\n    envs:\\n      personal:\\n        token: \\"ghp_your_personal_token\\"\\n      work:\\n        token: \\"ghp_your_work_token\\"\\n```\\n\\nNow you can use different tokens based on the environment:\\n\\n```bash\\n# Use personal token\\nmycli github-info personal facebook/react\\n\\n# Use work token\\nmycli github-info work your-company/private-repo\\n```\\n\\n## Step 8: Improve Error Handling\\n\\nLet\'s add better validation and error messages:\\n\\n```python\\ndef validate_repo_format(repo: str) -> bool:\\n    \\"\\"\\"Validate that repo is in owner/repo format.\\"\\"\\"\\n    if \\"/\\" not in repo:\\n        return False\\n\\n    parts = repo.split(\\"/\\")\\n    if len(parts) != 2:\\n        return False\\n\\n    owner, name = parts\\n    if not owner or not name:\\n        return False\\n\\n    return True\\n\\ndef main(tool, env, env_args, cli_args: Args):\\n    # Prompt for repo if not provided\\n    if not cli_args.repo.value:\\n        cli_args.repo.prompt()\\n\\n    # Validate format\\n    repo = cli_args.repo.value\\n    if not validate_repo_format(repo):\\n        log.error(\\"Invalid repository format\\")\\n        log.info(\\"Expected format: owner/repo\\")\\n        log.example(\\"mycli github-info facebook/react\\")\\n        return [\\"Error: Invalid repository format\\"]\\n\\n    # Rest of the implementation...\\n```\\n\\n## Step 9: Add Interactive Suggestions\\n\\nMake the tool more user-friendly with suggestions:\\n\\n```python\\nclass Args(ToolArgs):\\n    repo: PositionalArg[str] = Arg(\\n        None,\\n        prompt_message=\\"Enter repository (format: owner/repo)\\",\\n        prompt_suggestions=[\\n            \\"facebook/react\\",\\n            \\"microsoft/vscode\\",\\n            \\"vercel/next.js\\",\\n            \\"vuejs/vue\\"\\n        ],\\n        searchable=True,\\n        description=\\"GitHub repository in owner/repo format\\"\\n    )\\n\\n    show_details: OptionalArg[bool] = Arg(\\n        False,\\n        alias=\\"d\\",\\n        description=\\"Show detailed information\\"\\n    )\\n```\\n\\nNow when users are prompted, they\'ll see popular repositories as suggestions they can select or search through.\\n\\n## Complete Code\\n\\nHere\'s the complete tool implementation:\\n\\n```python\\n# custom_tools/github_info.py\\nfrom hexagon.support.output.printer import log\\nfrom hexagon.support.input.args import ToolArgs, PositionalArg, OptionalArg, Arg\\nimport urllib.request\\nimport json\\n\\nclass Args(ToolArgs):\\n    \\"\\"\\"Arguments for the GitHub info tool.\\"\\"\\"\\n\\n    repo: PositionalArg[str] = Arg(\\n        None,\\n        prompt_message=\\"Enter repository (format: owner/repo)\\",\\n        prompt_suggestions=[\\n            \\"facebook/react\\",\\n            \\"microsoft/vscode\\",\\n            \\"vercel/next.js\\",\\n            \\"vuejs/vue\\"\\n        ],\\n        searchable=True,\\n        description=\\"GitHub repository in owner/repo format\\"\\n    )\\n\\n    show_details: OptionalArg[bool] = Arg(\\n        False,\\n        alias=\\"d\\",\\n        description=\\"Show detailed information\\"\\n    )\\n\\ndef validate_repo_format(repo: str) -> bool:\\n    \\"\\"\\"Validate that repo is in owner/repo format.\\"\\"\\"\\n    if \\"/\\" not in repo:\\n        return False\\n\\n    parts = repo.split(\\"/\\")\\n    if len(parts) != 2:\\n        return False\\n\\n    owner, name = parts\\n    if not owner or not name:\\n        return False\\n\\n    return True\\n\\ndef main(tool, env, env_args, cli_args: Args):\\n    \\"\\"\\"Fetch and display GitHub repository information.\\n\\n    Args:\\n        tool: Tool configuration object\\n        env: Selected environment (or None)\\n        env_args: Environment-specific configuration\\n        cli_args: Parsed command-line arguments\\n    \\"\\"\\"\\n    # Prompt for repo if not provided\\n    if not cli_args.repo.value:\\n        cli_args.repo.prompt()\\n\\n    # Validate format\\n    repo = cli_args.repo.value\\n    if not validate_repo_format(repo):\\n        log.error(\\"Invalid repository format\\")\\n        log.info(\\"Expected format: owner/repo\\")\\n        log.example(\\"mycli github-info facebook/react\\")\\n        return [\\"Error: Invalid repository format\\"]\\n\\n    # Show what we\'re doing\\n    log.info(f\\"Fetching information for: {repo}\\")\\n\\n    # Make the API request\\n    try:\\n        url = f\\"https://api.github.com/repos/{repo}\\"\\n\\n        # Add authentication token if provided via environment\\n        headers = {}\\n        if env_args and isinstance(env_args, dict) and \\"token\\" in env_args:\\n            headers[\\"Authorization\\"] = f\\"token {env_args[\'token\']}\\"\\n\\n        request = urllib.request.Request(url, headers=headers)\\n        with urllib.request.urlopen(request) as response:\\n            data = json.loads(response.read().decode())\\n\\n        # Extract key information\\n        name = data[\\"full_name\\"]\\n        description = data[\\"description\\"] or \\"No description\\"\\n        stars = data[\\"stargazers_count\\"]\\n        forks = data[\\"forks_count\\"]\\n        language = data[\\"language\\"] or \\"Not specified\\"\\n\\n        # Display results\\n        log.panel(\\n            f\\"**{name}**\\\\n\\\\n{description}\\",\\n            title=\\"Repository Info\\"\\n        )\\n\\n        results = [\\n            f\\"\u2b50 Stars: {stars:,}\\",\\n            f\\"\ud83c\udf74 Forks: {forks:,}\\",\\n            f\\"\ud83d\udcbb Language: {language}\\"\\n        ]\\n\\n        # Show additional details if requested\\n        if cli_args.show_details.value:\\n            results.extend([\\n                f\\"\ud83d\udcc5 Created: {data[\'created_at\'][:10]}\\",\\n                f\\"\ud83d\udcdd Updated: {data[\'updated_at\'][:10]}\\",\\n                f\\"\ud83d\udc1b Open Issues: {data[\'open_issues_count\']}\\"\\n            ])\\n\\n        return results\\n\\n    except urllib.error.HTTPError as e:\\n        if e.code == 404:\\n            log.error(f\\"Repository not found: {repo}\\")\\n            return [f\\"Error: Repository \'{repo}\' not found\\"]\\n        elif e.code == 403:\\n            log.error(\\"API rate limit exceeded. Use a GitHub token.\\")\\n            return [\\"Error: API rate limit exceeded\\"]\\n        else:\\n            log.error(f\\"GitHub API error: {e.code}\\")\\n            return [f\\"Error: GitHub API returned {e.code}\\"]\\n\\n    except Exception as e:\\n        log.error(f\\"Unexpected error: {str(e)}\\")\\n        return [f\\"Error: {str(e)}\\"]\\n```\\n\\n## Key Takeaways\\n\\n**Arguments:**\\n- Use `PositionalArg` for required parameters\\n- Use `OptionalArg` for optional flags and parameters\\n- Always use `.value` to access the actual argument value\\n- Add `prompt_suggestions` for better UX\\n\\n**Error Handling:**\\n- Catch specific exceptions (HTTPError, FileNotFoundError, etc.)\\n- Provide helpful error messages\\n- Use `log.error()` for user-facing errors\\n- Return error strings in the results list\\n\\n**Output:**\\n- Use `log.info()` for progress messages\\n- Use `log.panel()` for highlighted information\\n- Return list of strings for final results\\n- Use emojis for visual appeal (optional)\\n\\n**Environment Support:**\\n- Use `env_args` for environment-specific configuration\\n- Check if `env_args` exists before using it\\n- Common use cases: API tokens, URLs, configuration\\n\\n## Next Steps\\n\\nNow that you\'ve built a custom tool, explore:\\n\\n- [Custom Tools Reference](/docs/advanced/custom-tools) - Complete API documentation\\n- [Prompting Guide](/docs/advanced/prompting) - Advanced interactive features\\n- [Output API](/docs/api/support/output) - Rich terminal output options\\n- [Storage API](/docs/api/support/storage) - Persisting data between runs"},{"id":"multi-environment-workflow","metadata":{"permalink":"/hexagon/blog/multi-environment-workflow","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2026-01-06-multi-environment-workflow.md","source":"@site/blog/2026-01-06-multi-environment-workflow.md","title":"Tutorial: Multi-Environment Workflow","description":"This tutorial demonstrates how to build a CLI with multiple environments for a realistic development workflow. You\'ll learn how to configure tools for different environments and use them effectively.","date":"2026-01-06T00:00:00.000Z","tags":[{"inline":false,"label":"Tutorial","permalink":"/hexagon/blog/tags/tutorial","description":"Step-by-step guides for using Hexagon"},{"inline":false,"label":"Environments","permalink":"/hexagon/blog/tags/environments","description":"Multi-environment configurations and workflows"},{"inline":false,"label":"Workflow","permalink":"/hexagon/blog/tags/workflow","description":"Team workflows and best practices"}],"readingTime":8.355,"hasTruncateMarker":true,"authors":[{"name":"Joaco Campero","title":"Creator of Hexagon","url":"https://github.com/lt-mayonesa","page":{"permalink":"/hexagon/blog/authors/joaco"},"socials":{"github":"https://github.com/lt-mayonesa"},"imageURL":"https://github.com/lt-mayonesa.png","key":"joaco"}],"frontMatter":{"slug":"multi-environment-workflow","title":"Tutorial: Multi-Environment Workflow","authors":["joaco"],"tags":["tutorial","environments","workflow"]},"unlisted":false,"prevItem":{"title":"Tutorial: Building a Custom Tool","permalink":"/hexagon/blog/building-custom-tool"},"nextItem":{"title":"Welcome to the Hexagon Blog","permalink":"/hexagon/blog/welcome-to-hexagon"}},"content":"This tutorial demonstrates how to build a CLI with multiple environments for a realistic development workflow. You\'ll learn how to configure tools for different environments and use them effectively.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Scenario\\n\\nYou\'re building a CLI for your team that deploys a web application to three environments:\\n- **Development** - Local development server\\n- **Staging** - Testing environment for QA\\n- **Production** - Live production servers\\n\\nEach environment has different configurations for:\\n- API URLs\\n- Database connections\\n- Deployment scripts\\n- Monitoring dashboards\\n\\n## Step 1: Define Environments\\n\\nStart by defining your environments in `app.yaml`:\\n\\n```yaml\\ncli:\\n  name: Deploy CLI\\n  command: deploy-cli\\n  custom_tools_dir: ./custom_tools\\n\\nenvs:\\n  - name: development\\n    alias: dev\\n    long_name: Development Environment\\n    description: Local development environment\\n\\n  - name: staging\\n    alias: stg\\n    long_name: Staging Environment\\n    description: Pre-production testing environment\\n\\n  - name: production\\n    alias: prod\\n    long_name: Production Environment\\n    description: Live production environment\\n```\\n\\n**Key points:**\\n- `name`: Full environment name (required)\\n- `alias`: Short form for quick access (recommended)\\n- `long_name`: Display name in menus\\n- `description`: Explains the environment\'s purpose\\n\\n## Step 2: Add Web Tools with Environment URLs\\n\\nLet\'s add tools to open various dashboards specific to each environment:\\n\\n```yaml\\ntools:\\n  - name: dashboard\\n    alias: dash\\n    long_name: Application Dashboard\\n    description: Open the application dashboard\\n    type: web\\n    action: open_link\\n    envs:\\n      development: http://localhost:3000\\n      staging: https://staging.myapp.com\\n      production: https://myapp.com\\n\\n  - name: api-docs\\n    alias: api\\n    long_name: API Documentation\\n    description: Open API documentation\\n    type: web\\n    action: open_link\\n    envs:\\n      development: http://localhost:8080/docs\\n      staging: https://staging-api.myapp.com/docs\\n      production: https://api.myapp.com/docs\\n\\n  - name: logs\\n    alias: l\\n    long_name: Application Logs\\n    description: Open log viewer\\n    type: web\\n    action: open_link\\n    envs:\\n      development: http://localhost:9000\\n      staging: https://logs.staging.myapp.com\\n      production: https://logs.myapp.com\\n```\\n\\n**Testing:**\\n```bash\\n# Open development dashboard\\ndeploy-cli dashboard dev\\n\\n# Open staging API docs\\ndeploy-cli api-docs staging\\n\\n# Production logs (will prompt for environment if not specified)\\ndeploy-cli logs\\n```\\n\\n## Step 3: Add Environment-Specific Shell Commands\\n\\nNow let\'s add deployment tools with different commands per environment:\\n\\n```yaml\\ntools:\\n  - name: deploy\\n    alias: d\\n    long_name: Deploy Application\\n    description: Deploy the application\\n    type: shell\\n    envs:\\n      development: |\\n        echo \\"\ud83d\ude80 Deploying to development...\\"\\n        npm run build:dev\\n        docker-compose -f docker-compose.dev.yml up -d\\n        echo \\"\u2705 Development deployment complete!\\"\\n      staging: |\\n        echo \\"\ud83d\ude80 Deploying to staging...\\"\\n        npm run build:staging\\n        ./scripts/deploy-staging.sh\\n        echo \\"\u2705 Staging deployment complete!\\"\\n      production: |\\n        echo \\"\ud83d\ude80 Deploying to production...\\"\\n        npm run build:prod\\n        ./scripts/deploy-production.sh --verify\\n        echo \\"\u2705 Production deployment complete!\\"\\n\\n  - name: rollback\\n    alias: rb\\n    long_name: Rollback Deployment\\n    description: Rollback to previous version\\n    type: shell\\n    envs:\\n      development: docker-compose -f docker-compose.dev.yml down && git checkout HEAD~1\\n      staging: ./scripts/rollback.sh staging\\n      production: ./scripts/rollback.sh production --confirm\\n```\\n\\n**Note:** Use `|` for multi-line commands in YAML.\\n\\n## Step 4: Create Custom Tool with Environment Logic\\n\\nLet\'s create a custom tool that behaves differently based on the environment:\\n\\n```python\\n# custom_tools/health_check.py\\nfrom hexagon.support.output.printer import log\\nfrom hexagon.support.input.args import ToolArgs, OptionalArg, Arg\\nimport urllib.request\\nimport json\\n\\nclass Args(ToolArgs):\\n    verbose: OptionalArg[bool] = Arg(\\n        False,\\n        alias=\\"v\\",\\n        description=\\"Show detailed health check information\\"\\n    )\\n\\ndef main(tool, env, env_args, cli_args: Args):\\n    \\"\\"\\"Check application health for the selected environment.\\"\\"\\"\\n\\n    # env_args contains the environment-specific configuration\\n    if not env_args:\\n        log.error(\\"No configuration for this environment\\")\\n        return [\\"Error: Environment not configured\\"]\\n\\n    # Extract configuration\\n    config = env_args\\n    api_url = config.get(\\"api_url\\")\\n    check_interval = config.get(\\"check_interval\\", 30)\\n    critical = config.get(\\"critical\\", False)\\n\\n    # Show environment info\\n    env_name = env.name if env else \\"unknown\\"\\n    log.info(f\\"Checking health for: {env_name}\\")\\n\\n    if critical:\\n        log.panel(\\n            \\"\u26a0\ufe0f  This is a CRITICAL environment\\\\nChanges require approval\\",\\n            title=\\"Warning\\"\\n        )\\n\\n    # Perform health check\\n    try:\\n        health_url = f\\"{api_url}/health\\"\\n        log.info(f\\"Checking: {health_url}\\")\\n\\n        with urllib.request.urlopen(health_url, timeout=5) as response:\\n            data = json.loads(response.read().decode())\\n\\n        status = data.get(\\"status\\", \\"unknown\\")\\n\\n        if status == \\"healthy\\":\\n            log.info(\\"\u2705 Service is healthy\\")\\n            results = [\\n                f\\"Status: {status}\\",\\n                f\\"Check interval: {check_interval}s\\"\\n            ]\\n\\n            if cli_args.verbose.value:\\n                # Show additional details in verbose mode\\n                results.extend([\\n                    f\\"Uptime: {data.get(\'uptime\', \'N/A\')}\\",\\n                    f\\"Version: {data.get(\'version\', \'N/A\')}\\",\\n                    f\\"Requests: {data.get(\'total_requests\', \'N/A\')}\\"\\n                ])\\n\\n            return results\\n        else:\\n            log.error(f\\"\u274c Service is {status}\\")\\n            return [f\\"Status: {status}\\"]\\n\\n    except urllib.error.URLError as e:\\n        log.error(f\\"Failed to reach service: {str(e)}\\")\\n        return [f\\"Error: Cannot connect to {api_url}\\"]\\n    except Exception as e:\\n        log.error(f\\"Health check failed: {str(e)}\\")\\n        return [f\\"Error: {str(e)}\\"]\\n```\\n\\nAdd the tool to your configuration with environment-specific settings:\\n\\n```yaml\\ntools:\\n  - name: health\\n    alias: h\\n    long_name: Health Check\\n    description: Check application health\\n    type: shell\\n    action: health_check\\n    envs:\\n      development:\\n        api_url: http://localhost:8080\\n        check_interval: 10\\n        critical: false\\n      staging:\\n        api_url: https://staging-api.myapp.com\\n        check_interval: 30\\n        critical: false\\n      production:\\n        api_url: https://api.myapp.com\\n        check_interval: 60\\n        critical: true  # Mark production as critical\\n```\\n\\n**Usage:**\\n```bash\\n# Basic health check\\ndeploy-cli health dev\\n\\n# Verbose health check\\ndeploy-cli health prod --verbose\\n```\\n\\n## Step 5: Use Format Strings for Dynamic Commands\\n\\nYou can use format strings to create dynamic commands based on environment:\\n\\n```yaml\\ntools:\\n  - name: ssh\\n    alias: s\\n    long_name: SSH to Server\\n    description: SSH into environment server\\n    type: shell\\n    envs:\\n      development: echo \\"Development runs locally (no SSH needed)\\"\\n      staging: ssh deploy@staging-{env.name}.myapp.com\\n      production: ssh deploy@{env_args}\\n    # For production, env_args could be: prod-server-01.myapp.com\\n\\n  - name: db-connect\\n    alias: db\\n    long_name: Database Connection\\n    description: Connect to database\\n    type: shell\\n    envs:\\n      development: psql -h localhost -U dev -d myapp_dev\\n      staging: psql -h {env_args.host} -U {env_args.user} -d myapp_staging\\n      production: psql -h {env_args.host} -U {env_args.user} -d myapp_prod\\n```\\n\\nFor complex env_args, use dictionary format:\\n\\n```yaml\\ntools:\\n  - name: db-connect\\n    type: shell\\n    envs:\\n      staging:\\n        host: staging-db.myapp.com\\n        user: staging_user\\n        database: myapp_staging\\n      production:\\n        host: prod-db.myapp.com\\n        user: prod_user\\n        database: myapp_prod\\n```\\n\\n## Step 6: Create Environment-Specific Tool Groups\\n\\nOrganize tools by environment with groups:\\n\\n```yaml\\ntools:\\n  - name: dev-tools\\n    long_name: Development Tools\\n    description: Tools for local development\\n    type: group\\n    tools:\\n      - name: start-local\\n        description: Start local development server\\n        type: shell\\n        action: npm run dev\\n\\n      - name: test\\n        description: Run tests\\n        type: shell\\n        action: npm test\\n\\n      - name: lint\\n        description: Run linter\\n        type: shell\\n        action: npm run lint\\n\\n  - name: prod-tools\\n    long_name: Production Tools\\n    description: Production management tools\\n    type: group\\n    tools:\\n      - name: deploy\\n        description: Deploy to production\\n        type: shell\\n        action: ./scripts/deploy-production.sh\\n\\n      - name: monitor\\n        description: Open monitoring dashboard\\n        type: web\\n        action: open_link\\n        envs:\\n          \\"*\\": https://monitoring.myapp.com\\n\\n      - name: incidents\\n        description: View incident reports\\n        type: web\\n        action: open_link\\n        envs:\\n          \\"*\\": https://incidents.myapp.com\\n```\\n\\n## Step 7: Set Default Environment\\n\\nFor convenience, set a default environment:\\n\\n```bash\\n# In your shell profile (.bashrc, .zshrc, etc.)\\nexport HEXAGON_DEFAULT_ENV=development\\n```\\n\\nNow when you run tools without specifying an environment, development will be used by default:\\n\\n```bash\\n# Uses development by default\\ndeploy-cli dashboard\\n\\n# Explicitly use staging\\ndeploy-cli dashboard staging\\n```\\n\\n## Step 8: Create Environment Aliases\\n\\nSave frequently used environment commands as aliases:\\n\\n```bash\\n# Run the save-alias tool\\ndeploy-cli save-alias\\n\\n# Select tool: deploy\\n# Select environment: production\\n# Enter alias: dp\\n\\n# Now you can use the alias\\ndeploy-cli dp  # Runs: deploy-cli deploy production\\n```\\n\\n## Best Practices\\n\\n### 1. Environment Naming\\n\\n**Good:**\\n```yaml\\nenvs:\\n  - name: development\\n    alias: dev\\n  - name: staging\\n    alias: stg\\n  - name: production\\n    alias: prod\\n```\\n\\n**Avoid:**\\n```yaml\\nenvs:\\n  - name: dev  # Too short for main name\\n  - name: stage  # Inconsistent with \\"production\\"\\n  - name: live  # Unclear what this means\\n```\\n\\n### 2. Configuration Management\\n\\n**Store sensitive data in environment variables:**\\n\\n```yaml\\ntools:\\n  - name: deploy\\n    type: shell\\n    action: deploy_tool\\n    envs:\\n      production:\\n        api_key: \\"${PROD_API_KEY}\\"  # Reference env variable\\n        database_url: \\"${PROD_DB_URL}\\"\\n```\\n\\n**Don\'t commit secrets to YAML:**\\n```yaml\\n# \u274c BAD - secrets in config file\\nenvs:\\n  production:\\n    api_key: \\"sk_live_abc123...\\"  # Never do this!\\n```\\n\\n### 3. Environment-Specific Safety\\n\\nAdd confirmation for critical environments:\\n\\n```python\\ndef main(tool, env, env_args, cli_args):\\n    # Check if production\\n    if env and env.name == \\"production\\":\\n        log.panel(\\n            \\"\u26a0\ufe0f  You are about to modify PRODUCTION\\\\nThis action cannot be undone\\",\\n            title=\\"Warning\\"\\n        )\\n        confirm = input(\\"Type \'CONFIRM\' to proceed: \\")\\n        if confirm != \\"CONFIRM\\":\\n            return [\\"Cancelled\\"]\\n\\n    # Proceed with operation\\n    # ...\\n```\\n\\n### 4. Consistent Tool Configuration\\n\\nEnsure all environments are configured for each tool:\\n\\n```yaml\\n# \u2705 GOOD - all environments configured\\n- name: dashboard\\n  type: web\\n  action: open_link\\n  envs:\\n    development: http://localhost:3000\\n    staging: https://staging.myapp.com\\n    production: https://myapp.com\\n\\n# \u274c BAD - missing staging\\n- name: dashboard\\n  type: web\\n  action: open_link\\n  envs:\\n    development: http://localhost:3000\\n    production: https://myapp.com\\n    # staging not configured - will fail!\\n```\\n\\n### 5. Use Wildcard for Common Values\\n\\nWhen all environments use the same value:\\n\\n```yaml\\n- name: docs\\n  type: web\\n  action: open_link\\n  envs:\\n    \\"*\\": https://docs.myapp.com  # Same for all environments\\n```\\n\\n## Complete Example\\n\\nHere\'s a complete `app.yaml` for a multi-environment CLI:\\n\\n```yaml\\ncli:\\n  name: MyApp CLI\\n  command: myapp\\n  custom_tools_dir: ./custom_tools\\n\\nenvs:\\n  - name: development\\n    alias: dev\\n    long_name: Development\\n    description: Local development environment\\n\\n  - name: staging\\n    alias: stg\\n    long_name: Staging\\n    description: Pre-production testing\\n\\n  - name: production\\n    alias: prod\\n    long_name: Production\\n    description: Live production environment\\n\\ntools:\\n  # Deployment\\n  - name: deploy\\n    alias: d\\n    long_name: Deploy Application\\n    type: shell\\n    action: deploy_app\\n    envs:\\n      development:\\n        target: local\\n        verify: false\\n      staging:\\n        target: staging-cluster\\n        verify: true\\n      production:\\n        target: production-cluster\\n        verify: true\\n        require_approval: true\\n\\n  # Monitoring\\n  - name: dashboard\\n    alias: dash\\n    type: web\\n    action: open_link\\n    envs:\\n      development: http://localhost:3000\\n      staging: https://staging.myapp.com\\n      production: https://myapp.com\\n\\n  - name: logs\\n    alias: l\\n    type: web\\n    action: open_link\\n    envs:\\n      development: http://localhost:9000\\n      staging: https://logs.staging.myapp.com\\n      production: https://logs.myapp.com\\n\\n  # Health checks\\n  - name: health\\n    alias: h\\n    type: shell\\n    action: health_check\\n    envs:\\n      development:\\n        api_url: http://localhost:8080\\n        critical: false\\n      staging:\\n        api_url: https://staging-api.myapp.com\\n        critical: false\\n      production:\\n        api_url: https://api.myapp.com\\n        critical: true\\n\\n  # Database\\n  - name: db-backup\\n    long_name: Database Backup\\n    type: shell\\n    envs:\\n      development: echo \\"Development DB backed up locally\\"\\n      staging: ./scripts/backup-db.sh staging\\n      production: ./scripts/backup-db.sh production --verify\\n```\\n\\n## Troubleshooting\\n\\n**Problem:** Environment not found\\n\\n```bash\\n$ myapp deploy prod\\nError: Environment \'prod\' not found\\n```\\n\\n**Solution:** Check your environment alias matches:\\n```yaml\\nenvs:\\n  - name: production\\n    alias: prod  # This must match the alias you use\\n```\\n\\n**Problem:** Tool fails with \\"No environment configuration\\"\\n\\n```bash\\n$ myapp deploy dev\\nError: No configuration for environment \'development\'\\n```\\n\\n**Solution:** Ensure tool has configuration for all environments:\\n```yaml\\n- name: deploy\\n  envs:\\n    development: ./deploy-dev.sh\\n    staging: ./deploy-staging.sh\\n    production: ./deploy-prod.sh  # Don\'t forget any!\\n```\\n\\n**Problem:** Environment variables not interpolated\\n\\n```bash\\n$ myapp ssh prod\\n# Shows: ssh user@{env_args.host} instead of actual host\\n```\\n\\n**Solution:** Format strings only work with inline commands, not in env_args values. Use this pattern instead:\\n\\n```yaml\\n- name: ssh\\n  type: shell\\n  action: \\"ssh user@{env_args}\\"  # Format string in action\\n  envs:\\n    production: prod-server-01.myapp.com\\n```\\n\\n## Next Steps\\n\\n- [Custom Tools](/docs/advanced/custom-tools) - Build sophisticated tools\\n- [Environments Guide](/docs/guides/environments) - Complete environment reference\\n- [Action Execution](/docs/advanced/action-execution) - Understand action resolution\\n- [Troubleshooting](/docs/guides/troubleshooting) - Fix common issues"},{"id":"welcome-to-hexagon","metadata":{"permalink":"/hexagon/blog/welcome-to-hexagon","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-05-19-welcome-to-hexagon.md","source":"@site/blog/2025-05-19-welcome-to-hexagon.md","title":"Welcome to the Hexagon Blog","description":"This blog will feature updates, tutorials, and insights about Hexagon - the tool that makes your team\'s knowledge truly accessible, truly shared, and truly empowering through custom CLIs.","date":"2025-05-19T00:00:00.000Z","tags":[{"inline":false,"label":"CLI","permalink":"/hexagon/blog/tags/cli","description":"Posts about command-line interfaces and Hexagon CLI features"}],"readingTime":0.41,"hasTruncateMarker":true,"authors":[{"name":"Joaco Campero","title":"Creator of Hexagon","url":"https://github.com/lt-mayonesa","page":{"permalink":"/hexagon/blog/authors/joaco"},"socials":{"github":"https://github.com/lt-mayonesa"},"imageURL":"https://github.com/lt-mayonesa.png","key":"joaco"}],"frontMatter":{"slug":"welcome-to-hexagon","title":"Welcome to the Hexagon Blog","authors":["joaco"],"tags":["cli"]},"unlisted":false,"prevItem":{"title":"Tutorial: Multi-Environment Workflow","permalink":"/hexagon/blog/multi-environment-workflow"}},"content":"This blog will feature updates, tutorials, and insights about Hexagon - the tool that makes your team\'s knowledge truly accessible, truly shared, and truly empowering through custom CLIs.\\n\\n\x3c!-- truncate --\x3e\\n\\nStay tuned for upcoming posts about:\\n\\n- New releases and features\\n- Best practices for creating effective team CLIs\\n- Advanced usage patterns and customizations\\n- Community highlights and use cases\\n\\nWe\'re excited to share more about Hexagon and how it can help your team streamline workflows and share knowledge effectively."}]}}')}}]);